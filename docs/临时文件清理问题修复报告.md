# 临时文件清理问题修复报告

## 问题描述

用户在导入设备数据时遇到以下警告：
```
2025-07-24 00:11:28.179 | WARNING  | app.api.v1.import_export:import_devices:106 | {} | 无法删除临时文件: C:\Users\lijia\AppData\Local\Temp\tmpsred3rpi.xlsx，可能被其他进程占用
```

## 问题根因分析

### 1. 文件句柄泄漏
在 `app/utils/import_export/base.py` 的 `_read_excel_file` 方法中：

```python
# 原有问题代码
async def _read_excel_file(self, file_path: str) -> pd.DataFrame:
    excel_file = pd.ExcelFile(file_path)  # 创建ExcelFile对象
    
    if "导入模板" in excel_file.sheet_names:
        df = pd.read_excel(file_path, sheet_name="导入模板")  # 重新打开文件
    
    return df  # excel_file对象没有被关闭！
```

**问题**：
1. `pd.ExcelFile(file_path)` 创建了文件句柄但没有显式关闭
2. `pd.read_excel(file_path, ...)` 又重新打开了同一个文件
3. 在Windows系统中，未关闭的文件句柄会阻止文件删除

### 2. 清理机制不够健壮
原有的文件清理机制只进行一次尝试，没有重试机制：

```python
# 原有清理代码
try:
    os.unlink(temp_path)
except PermissionError:
    logger.warning(f"无法删除临时文件: {temp_path}，可能被其他进程占用")
```

## 修复方案

### 修复1：使用上下文管理器正确处理文件句柄

**文件**: `app/utils/import_export/base.py`

```python
async def _read_excel_file(self, file_path: str) -> pd.DataFrame:
    """读取Excel文件"""
    try:
        # 使用上下文管理器确保文件正确关闭
        with pd.ExcelFile(file_path) as excel_file:
            logger.info(f"Excel文件工作表列表: {excel_file.sheet_names}")

            # 直接从ExcelFile对象读取数据
            if "导入模板" in excel_file.sheet_names:
                df = excel_file.parse("导入模板")
            elif self.config.sheet_name in excel_file.sheet_names:
                df = excel_file.parse(self.config.sheet_name)
            else:
                df = excel_file.parse(0)

        # 文件已在with语句中关闭，现在可以安全返回数据
        return df
    except Exception as e:
        logger.error(f"读取Excel文件失败，文件路径: {file_path}")
        raise BusinessException(f"读取Excel文件失败: {e}") from e
```

**关键改进**：
- 使用 `with pd.ExcelFile(file_path) as excel_file:` 确保文件正确关闭
- 使用 `excel_file.parse()` 而不是重新调用 `pd.read_excel()`
- 避免了文件句柄泄漏

### 修复2：增强文件清理机制

**文件**: `app/api/v1/import_export.py`

```python
async def _safe_cleanup_temp_file(file_path: str, max_retries: int = 3, delay: float = 0.1):
    """安全清理临时文件，支持重试机制"""
    for attempt in range(max_retries):
        try:
            if os.path.exists(file_path):
                os.unlink(file_path)
                logger.debug(f"临时文件已成功删除: {file_path}")
            return
        except FileNotFoundError:
            return
        except PermissionError as e:
            if attempt < max_retries - 1:
                logger.warning(f"删除临时文件失败(尝试 {attempt + 1}/{max_retries}): {file_path}，等待{delay}秒后重试")
                await asyncio.sleep(delay)
                delay *= 2  # 指数退避
            else:
                logger.warning(f"无法删除临时文件(已重试{max_retries}次): {file_path}: {e}")
```

**关键改进**：
- 重试机制：最多重试3次
- 指数退避：每次重试间隔时间翻倍
- 详细日志：记录每次重试的详情
- 异步支持：不阻塞主要业务流程

### 修复3：优化TempFileResponse类

```python
class TempFileResponse(FileResponse):
    async def __call__(self, scope, receive, send):
        try:
            await super().__call__(scope, receive, send)
        finally:
            # 下载完成后清理临时文件
            if self.cleanup_path:
                await _safe_cleanup_temp_file(str(self.cleanup_path))
```

## 修复效果

### 预期改善
1. **消除文件句柄泄漏**：Excel文件读取后立即关闭文件句柄
2. **提高清理成功率**：重试机制减少文件删除失败的概率
3. **减少警告日志**：大部分情况下临时文件能够成功清理
4. **改善用户体验**：减少临时文件积累

### 测试建议
1. 使用大量设备数据测试导入功能
2. 在不同的Windows版本上测试
3. 监控临时目录是否还有文件积累
4. 观察警告日志是否明显减少

## 兼容性说明
- 修复完全向后兼容
- 不影响现有API接口
- 不改变业务逻辑流程
- 仅优化了文件处理和清理机制

## Windows文件系统特性
Windows文件系统的特点是文件句柄管理较为严格：
- 文件被打开后，必须显式关闭才能删除
- 即使程序结束，文件句柄可能仍然被保留一段时间
- 使用上下文管理器是最佳实践，确保资源正确释放
