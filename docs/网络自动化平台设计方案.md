# 网络自动化平台设计方案

## 📋 项目概述

基于现有FastAPI RBAC架构，扩展开发网络自动化管理平台，支持1000+台网络设备的统一管理、查询、配置和监控。

### 核心特性
- **多品牌支持**：H3C (85%) + 华为 (10%) + 思科 (4%) + 其他 (1%)
- **动态认证**：支持动态密码 (98%) + 静态密码 (2%)
- **实时查询**：MAC地址查询、接口状态、配置信息等
- **CLI交互**：WebSocket + Xterm.js 实现类CRT体验
- **权限集成**：完全集成现有RBAC权限管理系统

## 🏗️ 技术架构

### 核心技术栈

| 组件                  | 版本        | 用途                      |
| --------------------- | ----------- | ------------------------- |
| **FastAPI**           | 0.115.12+   | 异步API框架，已有RBAC基础 |
| **Nornir**            | 3.5.0+      | 网络自动化任务编排        |
| **Scrapli[asyncssh]** | 2025.1.30+  | 异步SSH连接，支持动态密码 |
| **scrapli-community** | 2025.1.30+  | H3C等厂商驱动支持         |
| **TextFSM**           | 1.1.3+      | 命令输出解析              |
| **ntc-templates**     | 4.1.0+      | 通用解析模板库            |
| **WebSocket**         | FastAPI内置 | CLI实时交互               |
| **Xterm.js**          | 5.3.0+      | 前端终端模拟器            |
| **pandas**            | 2.0.0+      | 数据处理和分析            |
| **openpyxl**          | 3.1.0+      | Excel文件处理             |
| **python-multipart**  | 0.0.6+      | 文件上传处理              |

### 架构分层

```
┌─────────────────────────────────────────┐
│     前端层 (Vue3 + Xterm.js)            │
├─────────────────────────────────────────┤
│     API层 (FastAPI + RBAC权限控制)      │
├─────────────────────────────────────────┤
│     业务层 (Service + 操作日志)          │
├─────────────────────────────────────────┤
│     网络层 (Nornir + Scrapli)           │
├─────────────────────────────────────────┤
│     数据层 (PostgreSQL + Redis缓存)     │
└─────────────────────────────────────────┘
```

## 📊 数据模型设计

### 核心实体扩展

基于现有User、Role、Permission、OperationLog模型，新增网络设备相关模型：

#### 1. Site (基地/站点)
```python
class Site(BaseModel):
    site_code: str          # 基地编码 (cd, wx, sh)
    site_name: str          # 基地名称
    snmp_community: str     # SNMP社区字符串
    dynamic_password_rules: dict  # 动态密码规则
    description: str
```

#### 2. Vendor (设备品牌)
```python
class Vendor(BaseModel):
    vendor_code: str        # 厂商代码 (h3c, huawei, cisco)
    vendor_name: str        # 厂商名称 (华三, 华为, 思科)
    scrapli_platform: str   # Scrapli平台标识 (hp_comware, huawei_vrp, cisco_iosxe)
    default_username: str   # 默认用户名
    default_port: int       # 默认SSH端口
    connection_timeout: int # 连接超时时间(秒)
    command_timeout: int    # 命令超时时间(秒)
    supported_device_types: list[str]  # 支持的设备类型
    description: str
```

#### 3. Device (网络设备)
```python
class Device(BaseModel):
    hostname: str           # 设备主机名
    ip_address: str         # 管理IP地址
    device_type: str        # 设备类型 (switch, router, firewall)
    vendor_id: UUID         # 所属厂商ID
    model: str              # 设备型号
    layer: str              # 网络层级 (access, aggregation, core)
    site_id: UUID           # 所属基地
    
    # 物理信息
    rack_location: str      # 机架位置 (如: A01-U12)
    serial_number: str      # 设备序列号
    purpose: str            # 设备用途 (如: 办公网接入, 生产网汇聚)
    service_object: str     # 服务对象 (如: 研发部门, 生产车间)
    
    # 认证信息
    auth_type: str          # 认证类型 (dynamic, static)
    static_username: str    # 静态用户名 (仅静态密码时使用)
    static_password: str    # 静态密码(加密存储)
    ssh_port: int           # SSH端口 (默认22)
    
    # 状态信息
    is_active: bool         # 设备状态
    last_connected_at: datetime  # 最后连接时间
    connection_status: str  # 连接状态 (online, offline, unknown)
    
    # 扩展信息
    tags: list[str]         # 设备标签
    notes: str              # 备注信息
```

#### 4. QueryTemplate (查询模板)
```python
class QueryTemplate(BaseModel):
    template_name: str      # 模板名称
    template_type: str      # 模板类型 (mac_query, interface_status)
    vendor: str             # 适用厂商
    commands: list[str]     # 命令列表
    parser_type: str        # 解析器类型 (textfsm, regex)
    parser_template: str    # 解析模板
    description: str
```

#### 5. QueryHistory (查询历史)
```python
class QueryHistory(BaseModel):
    user_id: UUID           # 查询用户
    query_type: str         # 查询类型
    query_params: dict      # 查询参数
    target_devices: list[str]  # 目标设备
    results: dict           # 查询结果(JSON)
    execution_time: float   # 执行耗时
    status: str             # 执行状态
```

### 关系设计

```
Site ────────┐
             │ 1:N
             ▼
           Device
             ▲
             │ N:1
             │
           Vendor

User ────────┐
             │ 1:N
             ▼
       QueryHistory

QueryTemplate ────────┐
                      │ N:M
                      ▼
                    Device

Vendor ──────┐
             │ 1:N
             ▼
       QueryTemplate
```

## 🔐 权限系统扩展

### 权限枚举扩展

在现有`Permissions`类中添加网络设备相关权限：

```python
class Permissions:
    # 现有权限...
    
    # 基地管理
    SITE_CREATE = "site:create"
    SITE_READ = "site:read"
    SITE_UPDATE = "site:update"
    SITE_DELETE = "site:delete"
    SITE_ACCESS = "site:access"
    
    # 厂商管理
    VENDOR_CREATE = "vendor:create"
    VENDOR_READ = "vendor:read"
    VENDOR_UPDATE = "vendor:update"
    VENDOR_DELETE = "vendor:delete"
    VENDOR_ACCESS = "vendor:access"
    
    # 设备管理
    DEVICE_CREATE = "device:create"
    DEVICE_READ = "device:read"
    DEVICE_UPDATE = "device:update"
    DEVICE_DELETE = "device:delete"
    DEVICE_ACCESS = "device:access"
    DEVICE_CONNECT = "device:connect"  # 设备连接权限
    DEVICE_IMPORT = "device:import"    # 设备批量导入
    DEVICE_EXPORT = "device:export"    # 设备信息导出
    
    # 查询功能
    QUERY_MAC = "query:mac"            # MAC地址查询
    QUERY_INTERFACE = "query:interface"  # 接口查询
    QUERY_CONFIG = "query:config"      # 配置查询
    QUERY_BATCH = "query:batch"        # 批量查询
    QUERY_EXPORT = "query:export"      # 结果导出
    
    # 查询模板
    TEMPLATE_CREATE = "template:create"
    TEMPLATE_READ = "template:read"
    TEMPLATE_UPDATE = "template:update"
    TEMPLATE_DELETE = "template:delete"
    TEMPLATE_ACCESS = "template:access"
    
    # CLI功能
    CLI_ACCESS = "cli:access"          # CLI访问权限
    CLI_EXECUTE = "cli:execute"        # 命令执行权限
    CLI_CONFIG = "cli:config"          # 配置命令权限
    
    # 配置管理
    CONFIG_BACKUP = "config:backup"    # 配置备份
    CONFIG_RESTORE = "config:restore"  # 配置恢复
    CONFIG_COMPARE = "config:compare"  # 配置对比
```

### 权限分级策略

| 角色           | 权限范围      | 典型权限                    |
| -------------- | ------------- | --------------------------- |
| **网络管理员** | 全部权限      | 所有设备操作、配置管理      |
| **运维工程师** | 查询+基础操作 | 设备查询、状态监控、基础CLI |
| **值班人员**   | 只读查询      | MAC查询、接口状态查看       |
| **审计人员**   | 日志查看      | 操作日志、查询历史          |

## 🚀 核心功能实现

### 1. 设备连接管理

#### 动态密码认证
```python
class DynamicPasswordManager:
    """动态密码管理器"""
    
    def generate_username(self, site_code: str, layer: str) -> str:
        """根据基地和层级生成动态用户名"""
        base_map = {
            "cd": "opcd",  # 成都
            "wx": "opwx",  # 无锡
            "sh": "opsh",  # 上海
        }
        layer_map = {
            "access": "jr",      # 接入层
            "aggregation": "hj", # 汇聚层
            "core": "hx"         # 核心层
        }
        return f"{base_map[site_code]}{layer_map[layer]}"
    
    def get_auth_credentials(self, device: Device) -> tuple[str, str]:
        """获取设备认证凭据"""
        if device.auth_type == "static":
            return device.static_username, decrypt_password(device.static_password)
        else:
            # 动态密码认证
            username = self.generate_username(device.site.site_code, device.layer)
            password = self._get_dynamic_password()  # 从外部系统获取当前动态密码
            return username, password
```

#### 设备连接池
```python
class DeviceConnectionManager:
    """设备连接管理器"""
    
    async def get_connection(self, device: Device, manual_password: str = None):
        """获取设备连接"""
        # 获取认证凭据
        if manual_password:
            # 手动输入密码（用于动态密码）
            username = self.dynamic_password_manager.generate_username(
                device.site.site_code, device.layer
            )
            password = manual_password
        else:
            username, password = self.dynamic_password_manager.get_auth_credentials(device)
            
        # 获取厂商配置
        vendor = await self.vendor_dao.get_by_id(device.vendor_id)
        
        return await self.scrapli_manager.get_connection(
            host=device.ip_address,
            auth_username=username,
            auth_password=password,
            platform=vendor.scrapli_platform,
            port=device.ssh_port or vendor.default_port,
            timeout_socket=vendor.connection_timeout,
            timeout_ops=vendor.command_timeout
        )
```

### 2. 通用查询引擎

#### 查询引擎架构
```python
class QueryEngine:
    """通用查询引擎"""
    
    async def execute_query(
        self, 
        template: QueryTemplate, 
        devices: list[Device],
        params: dict
    ) -> dict:
        """执行查询"""
        results = {}
        
        # 使用Nornir并行执行
        async with self.nornir_manager.get_runner() as nr:
            for device in devices:
                task_result = await nr.run(
                    task=self._execute_device_query,
                    device=device,
                    template=template,
                    params=params
                )
                results[device.hostname] = task_result
                
        return results
    
    async def _execute_device_query(self, device, template, params):
        """单设备查询执行"""
        conn = await self.connection_manager.get_connection(device)
        
        raw_results = []
        for command in template.commands:
            # 参数化命令
            formatted_command = command.format(**params)
            result = await conn.send_command(formatted_command)
            raw_results.append(result.result)
            
        # 使用TextFSM解析
        parsed_results = self.parser.parse(
            template.parser_template, 
            "\n".join(raw_results)
        )
        
        return parsed_results
```

#### MAC地址查询实现
```python
class MacQueryService(BaseService):
    """MAC地址查询服务"""
    
    @log_query_with_context("mac_query")
    async def query_mac_address(
        self, 
        mac_address: str, 
        operation_context: OperationContext
    ) -> dict:
        """MAC地址查询"""
        # 标准化MAC地址格式
        normalized_mac = self._normalize_mac(mac_address)
        
        # 检查缓存
        cache_key = f"mac_query:{normalized_mac}"
        cached_result = await self.redis_cache.get(cache_key)
        if cached_result:
            return cached_result
            
        # 获取所有交换机设备
        switches = await self.device_dao.get_all(
            device_type="switch", 
            is_active=True
        )
        
        # 获取MAC查询模板
        template = await self.template_dao.get_one(
            template_type="mac_query"
        )
        
        # 执行查询
        results = await self.query_engine.execute_query(
            template=template,
            devices=switches,
            params={"mac_address": normalized_mac}
        )
        
        # 解析结果，找到MAC地址所在位置
        location = self._parse_mac_location(results)
        
        # 缓存结果（5分钟）
        await self.redis_cache.set(cache_key, location, 300)
        
        return location
```

### 3. CLI交互功能

#### WebSocket CLI处理器
```python
class CLIWebSocketHandler:
    """CLI WebSocket处理器"""
    
    async def handle_connection(self, websocket: WebSocket, device_id: str):
        """处理CLI连接"""
        await websocket.accept()
        
        # 权限验证
        user = await self.auth_service.get_current_user(websocket)
        if not await self.permission_manager.check_permission(
            user, Permissions.CLI_ACCESS
        ):
            await websocket.close(code=4003, reason="权限不足")
            return
            
        # 获取设备连接
        device = await self.device_dao.get_by_id(device_id)
        device_conn = await self.connection_manager.get_connection(device)
        
        try:
            # 建立CLI会话
            async with device_conn.channel() as channel:
                # 启动双向数据转发
                await asyncio.gather(
                    self._forward_to_device(websocket, channel),
                    self._forward_to_client(channel, websocket)
                )
        except Exception as e:
            await websocket.close(code=4000, reason=str(e))
    
    async def _forward_to_device(self, websocket, channel):
        """转发客户端输入到设备"""
        async for message in websocket.iter_text():
            # 命令权限检查
            if self._is_config_command(message):
                if not await self.permission_manager.check_permission(
                    self.current_user, Permissions.CLI_CONFIG
                ):
                    await websocket.send_text("错误: 配置命令权限不足\n")
                    continue
                    
            # 记录命令日志
            await self._log_cli_command(message)
            
            # 发送到设备
            await channel.send_input(message)
    
    async def _forward_to_client(self, channel, websocket):
        """转发设备输出到客户端"""
        async for output in channel.iter_output():
            await websocket.send_text(output)
```

### 4. 查询模板管理

#### 模板定义示例
```python
# H3C MAC查询模板
H3C_MAC_TEMPLATE = {
    "template_name": "H3C MAC地址查询",
    "vendor": "h3c",
    "commands": [
        "display mac-address {mac_address}",
        "display interface brief"
    ],
    "parser_template": """
Value VLAN (\d+)
Value MAC ([a-fA-F0-9-]+)
Value TYPE (\w+)
Value INTERFACE (\S+)
Value AGING (\d+)

Start
  ^\s*${VLAN}\s+${MAC}\s+${TYPE}\s+${INTERFACE}\s+${AGING} -> Record
"""
}

# 华为MAC查询模板
HUAWEI_MAC_TEMPLATE = {
    "template_name": "华为 MAC地址查询",
    "vendor": "huawei",
    "commands": [
        "display mac-address {mac_address}"
    ],
    "parser_template": """
Value VLAN (\d+)
Value MAC ([a-fA-F0-9-]+)
Value TYPE (\w+)
Value INTERFACE (\S+)

Start
  ^\s*${VLAN}\s+${MAC}\s+${TYPE}\s+${INTERFACE} -> Record
"""
}
```

## 📡 API接口设计

### 基地管理 (`/api/v1/sites`)
```python
@router.get("", response_model=SiteListResponse)
async def list_sites(
    query: SiteListRequest = Depends(),
    operation_context: OperationContext = Depends(require_permission(Permissions.SITE_READ))
):
    """获取基地列表"""

@router.post("", response_model=SiteResponse)
async def create_site(
    site_data: SiteCreateRequest,
    operation_context: OperationContext = Depends(require_permission(Permissions.SITE_CREATE))
):
    """创建基地"""
```

### 厂商管理 (`/api/v1/vendors`)
```python
@router.get("", response_model=VendorListResponse)
async def list_vendors(
    query: VendorListRequest = Depends(),
    operation_context: OperationContext = Depends(require_permission(Permissions.VENDOR_READ))
):
    """获取厂商列表"""

@router.post("", response_model=VendorResponse)
async def create_vendor(
    vendor_data: VendorCreateRequest,
    operation_context: OperationContext = Depends(require_permission(Permissions.VENDOR_CREATE))
):
    """创建厂商"""

@router.get("/{vendor_id}/device-types", response_model=DeviceTypeListResponse)
async def get_vendor_device_types(
    vendor_id: UUID,
    operation_context: OperationContext = Depends(require_permission(Permissions.VENDOR_READ))
):
    """获取厂商支持的设备类型"""
```

### 设备管理 (`/api/v1/devices`)
```python
@router.get("", response_model=DeviceListResponse)
async def list_devices(
    query: DeviceListRequest = Depends(),
    operation_context: OperationContext = Depends(require_permission(Permissions.DEVICE_READ))
):
    """获取设备列表"""

@router.post("", response_model=DeviceResponse)
async def create_device(
    device_data: DeviceCreateRequest,
    operation_context: OperationContext = Depends(require_permission(Permissions.DEVICE_CREATE))
):
    """创建设备"""

@router.post("/{device_id}/connect", response_model=ConnectionResponse)
async def test_device_connection(
    device_id: UUID,
    connection_data: DeviceConnectionRequest,
    operation_context: OperationContext = Depends(require_permission(Permissions.DEVICE_CONNECT))
):
    """测试设备连接（支持手动密码输入）"""

@router.post("/import", response_model=DeviceImportResponse)
async def import_devices(
    file: UploadFile,
    operation_context: OperationContext = Depends(require_permission(Permissions.DEVICE_IMPORT))
):
    """批量导入设备（Excel/CSV）"""

@router.get("/export", response_class=FileResponse)
async def export_devices(
    query: DeviceExportRequest = Depends(),
    operation_context: OperationContext = Depends(require_permission(Permissions.DEVICE_EXPORT))
):
    """导出设备信息"""

@router.get("/{device_id}/credentials", response_model=DeviceCredentialsResponse)
async def get_device_credentials(
    device_id: UUID,
    operation_context: OperationContext = Depends(require_permission(Permissions.DEVICE_CONNECT))
):
    """获取设备认证信息（动态用户名生成）"""
```

### 查询功能 (`/api/v1/queries`)
```python
@router.post("/mac", response_model=MacQueryResponse)
async def query_mac_address(
    query_data: MacQueryRequest,
    operation_context: OperationContext = Depends(require_permission(Permissions.QUERY_MAC))
):
    """MAC地址查询"""

@router.post("/batch", response_model=BatchQueryResponse)
async def execute_batch_query(
    query_data: BatchQueryRequest,
    operation_context: OperationContext = Depends(require_permission(Permissions.QUERY_BATCH))
):
    """批量查询"""
```

### CLI功能 (`/api/v1/cli`)
```python
@router.websocket("/devices/{device_id}")
async def cli_websocket(
    websocket: WebSocket,
    device_id: UUID,
    # 权限验证在WebSocket处理器中进行
):
    """设备CLI WebSocket连接"""
```

## 🔄 开发实施计划

### 第一阶段：基础模型和权限扩展 (1-2周)
1. **权限枚举扩展**：在`Permissions`类中添加网络设备相关权限
2. **数据模型创建**：Vendor、Site、Device、QueryTemplate、QueryHistory模型
3. **数据库迁移**：使用aerich创建迁移文件
4. **基础DAO层**：继承BaseDAO，实现基础CRUD操作
5. **设备导入导出**：实现Excel/CSV格式的设备批量导入导出功能

### 第二阶段：设备连接和认证 (2-3周)
1. **动态密码管理器**：实现手动输入密码
2. **设备连接管理**：集成Scrapli，支持多厂商连接
3. **连接池管理**：优化连接复用和超时处理
4. **认证测试**：验证各厂商设备连接稳定性

### 第三阶段：查询引擎开发 (2-3周)
1. **Nornir集成**：实现并行任务执行框架
2. **TextFSM解析器**：集成ntc-templates解析库
3. **查询模板管理**：实现模板CRUD和版本管理
4. **MAC查询功能**：实现核心MAC地址查询功能

### 第四阶段：CLI交互功能 (2-3周)
1. **WebSocket处理器**：实现CLI连接和权限验证
2. **命令过滤器**：实现危险命令拦截和权限控制
3. **会话管理**：实现多用户并发CLI会话
4. **前端集成**：集成Xterm.js实现终端界面

### 第五阶段：高级功能和优化 (2-3周)
1. **批量查询**：实现多设备并行查询
2. **结果导出**：支持Excel、CSV格式导出
3. **查询历史**：实现查询记录和结果回放
4. **性能优化**：Redis缓存、连接池优化

### 第六阶段：测试和部署 (1-2周)
1. **单元测试**：核心功能测试覆盖
2. **集成测试**：端到端功能验证
3. **性能测试**：并发连接和查询压力测试
4. **生产部署**：Docker容器化和监控配置

## 📈 性能优化策略

### 连接优化
- **连接池管理**：复用设备连接，减少建连开销
- **并发控制**：限制单设备并发连接数，避免设备过载
- **超时处理**：合理设置连接和命令超时时间

### 查询优化
- **结果缓存**：Redis缓存常用查询结果，TTL 5-10分钟
- **并行执行**：Nornir并行查询多设备，提升效率
- **智能路由**：根据查询类型选择最优设备子集

### 缓存策略
- **查询结果缓存**：MAC查询、接口状态等缓存5-10分钟
- **设备信息缓存**：设备列表、模板信息缓存1小时
- **权限缓存**：复用现有PermissionCache机制

## 🔒 安全考虑

### 认证安全
- **密码加密**：静态密码使用AES加密存储
- **动态密码**：支持用户手动输入，不持久化存储
- **连接审计**：记录所有设备连接和命令执行

### 权限控制
- **分级权限**：查询、连接、配置三级权限控制
- **命令过滤**：危险命令拦截和白名单机制
- **操作审计**：完整的操作日志和权限验证记录

### 网络安全
- **SSH密钥**：支持密钥认证方式
- **网络隔离**：管理网络和业务网络分离
- **访问控制**：基于IP和时间的访问限制

## 📊 监控和运维

### 系统监控
- **连接状态**：实时监控设备连接状态
- **查询性能**：统计查询响应时间和成功率
- **资源使用**：监控CPU、内存、网络使用情况

### 业务监控
- **设备健康度**：基于连接成功率评估设备状态
- **用户活跃度**：统计用户查询频次和使用模式
- **错误分析**：分析连接失败和查询异常原因

### 告警机制
- **设备离线告警**：设备连接失败超过阈值时告警
- **性能告警**：查询响应时间超过阈值时告警
- **安全告警**：异常登录和危险操作告警

## 🎯 总结

本设计方案基于现有FastAPI RBAC架构，通过最小化扩展实现网络自动化平台的核心功能：

### 核心优势
1. **架构一致性**：完全遵循现有RBAC模式，无缝集成
2. **技术先进性**：异步架构 + 现代化网络自动化工具链
3. **扩展性强**：模块化设计，支持新厂商和功能扩展
4. **安全可靠**：多层权限控制 + 完整操作审计
5. **性能优异**：并行查询 + 多级缓存 + 连接池优化
6. **管理便捷**：厂商信息集中管理 + 设备批量导入导出功能

### 实施建议
1. **分阶段开发**：按照6个阶段逐步实施，降低风险
2. **权限优先**：首先完成权限扩展，确保安全基础
3. **核心功能先行**：优先实现MAC查询等核心业务功能
4. **充分测试**：重点测试多厂商兼容性和并发性能
5. **渐进部署**：先小范围试点，再全面推广

通过本方案的实施，将构建一个功能完善、性能优异、安全可靠的网络自动化管理平台，有效提升网络运维效率和管理水平。